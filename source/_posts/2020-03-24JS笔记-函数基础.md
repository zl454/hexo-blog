---
title: 函数基础
tags: JavaScript基础
categories: JavaScript
date: 2020-03-24 10:09:51
---

# 1.函数的定义/声明

**函数**：就是将一些功能或语句进行**封装**，在需要的时候，通过**调用**的形式，执行这些语句。

js是解释性语言,在当前script标签代码执行的开始阶段,就会将普通函数放入在堆中,

只是放入在堆中,但是函数中的内容并没有解析执行,没进行一次函数执行就会解析一次

## 方式一：利用函数关键字自定义函数（命名函数）

最常用的方式

```javascript
function 函数名([形参1,形参2...形参N]){  // 备注：语法中的中括号，表示“可选”
	语句...
}
    
function fun1(a, b){
	return a+b;
}
```

## 方式二：函数表达式（匿名函数）

使用`函数表达式`来创建一个函数。语法：

```javascript
var 变量名  = function([形参1,形参2...形参N]){
	语句....
}

var fun2 = function() {
	console.log("我是匿名函数中封装的代码");
};
```

## 方式三：使用构造函数 new Function()

注意，Function 里面的参数都必须是**字符串**格式。也就是说，形参也必须放在**字符串**里；函数体也是放在**字符串**里包裹起来，放在 Function 的最后一个参数的位置。

方式3的写法很少用，原因如下：

- 不方便书写：写法过于啰嗦和麻烦。
- 执行效率较低：首先需要把字符串转换为 js 代码，然后再执行。

优点：可以用任何语言传入该JS语言并执行

```javascript
var 变量名/函数名  = new Function('形参1', '形参2', '函数体');

var fun3 = new Function('a', 'b', 'console.log("我是函数内部的内容");  console.log(a + b);');
fun3(1, 2); // 调用函数
```

## 总结

1、**所有的函数，都是 `Fuction` 的“实例”**（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。

2、函数既然是实例对象，那么，**函数也属于“对象”**。还可以通过如下特征，来佐证函数属于对象：

（1）我们直接打印某一个函数，比如 `console.log(fun2)`，发现它的里面有`__proto__`。（这个是属于原型的知识）

（2）我们还可以打印 `console.log(fun2 instanceof Object)`，发现打印结果为 `true`。这说明 fun2 函数就是属于 Object。

## 函数的参数：形参和实参

**形参：**

- 概念：形式上的参数。定义函数时传递的参数，当时并不知道是什么值。

- 定义函数时，可以在函数的`()`中来指定一个或多个形参。

- 多个形参之间使用`,`隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。

**实参**：

- 概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。

- 在调用函数时，可以在函数的 `()`中指定实参。

注意：实际参数和形式参数的个数，一般要相同。

### 实参的类型

函数的实参可以是任意的数据类型。

调用函数时，解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。

### 实参的数量（实参和形参的个数不匹配时）

调用函数时，解析器也不会检查实参的数量。

- 如果实参的数量多余形参的数量，多余实参不会被赋值。

- 如果实参的数量少于形参的数量，多余的形参会被定义为 undefined。表达式的运行结果为 NaN。

# 2.函数的调用

## 方式1：普通函数的调用

函数调用的语法：

```javascript
函数名();
函数名.call();
```

代码举例：

```javascript
function fn1() {
	console.log('我是函数体里面的内容1');
}

function fn2() {
	console.log('我是函数体里面的内容2');
}
fn1(); // 调用函数
fn2.call(); // 调用函数
```

### 方式2：通过对象的方法来调用

```javascript
var obj = {
	a: 'tiantian',
	fn2: function() {
		console.log('天将降大任于斯人也');
	},
};

obj.fn2(); // 调用函数
```

如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的**方法**。

## 方式3：立即执行函数

```javascript
(function() {
	console.log('我是立即执行函数');
})();

(function(a, b) {
		console.log("a = " + a);
		console.log("b = " + b);
	})(123, 456);
```

立即执行函数在定义后，会自动调用，只能执行一次,执行完成后再也找不到了,变成孤儿对象(有引用的,不可被回收)

上面讲到的这三种方式，是用得最多的。

## 方式4：通过构造函数来调用代码举例：

```javascript
function Fun3() {
	console.log('abcdefg');
}
new Fun3();
```

这种方式用得不多。

## 方式5：绑定事件函数

先了解 

## 方式6：定时器函数

代码举例：（每间隔一秒，将 数字 加1）

```javascript
    let num = 1;
   setInterval(function () {
       num ++;
       console.log(num);
   }, 1000);
```

涉及到定时器

# 3.函数相关知识点

## 1.函数名、函数体和函数加载问题（重要）

**函数名 == 整个函数**。举例：

```javascript
console.log(fn) == console.log(function fn(){alert(1)});

//定义fn方法
function fn(){
	alert(1)
};
```

当调用一个函数时，通常使用`函数()`这种格式；可如果直接使用`函数`这种格式，它的作用相当于整个函数。

**函数的加载问题**：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。

## 2.fn()  和 fn 的区别（重要）

- `fn()`：调用函数。调用之后，还获取了函数的返回值。
- `fn`：函数对象。相当于直接获取了整个函数对象。

## 3.break、continue、return 的区别

- break ：结束当前的循环体（如 for、while）

- continue ：跳出本次循环，继续执行下次循环（如 for、while）

- return ：1、退出循环。2、返回 return 语句中的值，同时结束当前的函数体内的代码，退出当前函数。

## 4.方法

如果直接是`fn()`，那就说明是函数调用。如果是`XX.fn()`的这种形式，那就说明是**方法**调用。

## 5.函数的回调

参数如果传入的是一个函数名,在当前函数中运行了这个参数,这就是回调

```javascript
function fn1(o,fn) {
    o.a+=1;
    fn(o);
}
// fn1不会改变
function fn2(_o) {
    _o.a+=10;
}

function fn3(_o) {
    _o.b=20;
}

var obj4={a:1};
fn1(obj4,fn2);
console.log(obj4); //打印{a:12}
//  fn1(obj4,fn3);
//console.log(obj4);// 打印{a:2,b:20}
```

## 6.函数的递归

函数执行自己

```javascript
var sum1=0;
var i=0;
function fn8() {
	if(i===100){
	return;//跳出函数外
	}
	sum1+=i;
	i++;
	fn8();   //执行自己，形成循环
}

fn8();
console.log(sum1);
```

# 4.变量

## 1.变量的作用域

根据作用域的不同，变量可以分为两类：全局变量、局部变量。

**全局变量**：

- 在全局作用域下声明的变量，叫「全局变量」。在全局作用域的任何一地方，都可以访问这个变量。

- 在全局作用域下，使用 var 声明的变量是全局变量。

- 特殊情况：在函数内不使用 var 声明的变量也是全局变量（不建议这么用）。

**局部变量**：

- 定义在函数作用域的变量，叫「局部变量」。

- 在函数内部，使用 var 声明的变量是局部变量。

- 函数的**形参**也是属于局部变量。

从执行效率来看全局变量和局部变量：

- 全局变量：只有浏览器关闭时才会被销毁，比较占内存。

- 局部变量：当其所在的代码块运行结束后，就会被销毁，比较节约内存空间。

### 作用域的上下级关系

当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（**就近原则**）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错 ReferenceError。

在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用`window.a`）

## 2.声明提前

**变量的声明提前（变量提升）**

使用var关键字声明的变量（ 比如 `var a = 1`），**会在所有的代码执行之前被声明**（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写`a = 1`），则变量不会被声明提前。

**函数的声明提前**

使用`函数声明`的形式创建的函数`function foo(){}`，**会被声明提前**。所以，在代码顺序里，可以先调用函数，再定义函数

使用`函数表达式`创建的函数`var foo = function(){}`，**不会被声明提前**，所以不能在声明前调用。

## 3.函数作用域

**1**：在函数作用域中，也有声明提前的特性：

- 函数中，使用var关键字声明的变量，会在函数中所有的代码执行之前被声明。

- 函数中，没有var声明的变量都是**全局变量**，而且并不会提前声明。

  ```javascript
      var a = 1;
  
      function foo() {
          console.log(a);
          a = 2;     // 此处的a相当于window.a
      }
  
      foo();  //打印结果1
      console.log(a);   //打印结果是2
  
  ```


**2**：定义形参就相当于在函数作用域中声明了变量。

```javascript
    function fun6(e) { // 这个函数中，因为有了形参 e，此时就相当于在函数内部的第一行代码里，写了 var e;
        console.log(e);
    }

    fun6();  //打印结果为 undefined
    fun6(123);//打印结果为123
```

## 4.作用域链

- 只要是代码，就至少有一个作用域

- 写在函数内部的局部作用域

- 如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域

**作用域链**：内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是**就近原则**。

# 5.点击执行函数写法（常用）

```javascript
div.addEventListener("click",clickHandler);
        function clickHandler(e) {
        }
```

